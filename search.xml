<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>EAS help make the Google Pixel the fastest Android phone</title>
      <link href="/EAS-help-make-the-Google-Pixel-the-fastest-Android-phone/"/>
      <url>/EAS-help-make-the-Google-Pixel-the-fastest-Android-phone/</url>
      
        <content type="html"><![CDATA[<h3 id="The-Evolution-of-the-Linux-Load-Schedulers"><a href="#The-Evolution-of-the-Linux-Load-Schedulers" class="headerlink" title="The Evolution of the Linux Load Schedulers"></a>The Evolution of the Linux Load Schedulers</h3><h4 id="Round-Robin-Scheduling"><a href="#Round-Robin-Scheduling" class="headerlink" title="Round-Robin Scheduling"></a>Round-Robin Scheduling</h4><p>Round robin processing is a simple concept to explain and understand, and an even simpler one to grasp its disadvantages. Round-robin uses time slicing to allocate time to each process. Let’s assume we have four processes running on our computer.</p><ul><li>Process A</li><li>Process B</li><li>Process C</li><li>Process D</li></ul><p>Now, let’s do the job of the round-robin scheduler. We will allocate 100 milliseconds (time-slicing) to each process before moving on to the next. This means Process A can take 100 milliseconds to do its processing, then it moves to Process B and so on. If an application’s job takes 250 milliseconds to do, it will need to go through this process 3 times just to finish its work! Now scale this across different cores, so that Process A and Process B are allocated to core 1, and Process C and Process D are allocated to core 2. This was replaced by O(n) scheduling (which was like round-robin, but using epochs and allowing dynamic allocation of time), then O(1) scheduling (minimized overhead, unlimited process support), then finally the Completely Fair Scheduler (CFS). CFS was merged into the Linux kernel version 2.6.23 in October 2007. It has been overhauled since and is still the default scheduler in Linux systems.<br><img src="RoundRobin-675x1024.jpg" alt="avatar"></p><h3 id="Completely-Fair-Scheduler"><a href="#Completely-Fair-Scheduler" class="headerlink" title="Completely Fair Scheduler"></a>Completely Fair Scheduler</h3><p>The Completely Fair Scheduler has existed in Android since its inception and is used on non-big.LITTLE devices. It uses an intelligent algorithm to determine processing order, time allocated etc. It is an example of a working implementation of the well-studied scheduling algorithm called “weighted fair queueing.” This basically focuses on providing priority to system processes and other high priority processes running on the machine. If it were to run on a big.LITTLE device, all cores would be perceived as equal. This is bad, as low power cores may be forced to run intensive applications, or even worse, the opposite may occur. The decoding for listening to music may be done on the big core, for example, increasing power consumption needlessly. This is why we need a new scheduler for big.LITTLE, one which can actually recognise and utilise the difference in cores in a power efficient manner. That’s where Heterogeneous Multi-Processing (HMP) comes in, the standard load scheduler most Android phones are running now.</p><h3 id="Heterogeneous-Multi-Processing"><a href="#Heterogeneous-Multi-Processing" class="headerlink" title="Heterogeneous Multi-Processing"></a>Heterogeneous Multi-Processing</h3><p>This is the standard load scheduler for any big.LITTLE device released in recent years, other than the Google Pixel. HMP makes use of the big.LITTLE architecture, delegating low priority, less intensive work to the little cores which consume less power. HMP is “safe” wherein it knows what should go to the big cores and what should go to the little cores, without making mistakes. It just works and requires a lot less effort to set up on the development side than something like EAS, which we’ll get into in a moment. HMP is just an extension of CFS to make it power aware.</p><p>HMP doesn’t take guesses, nor does it predict future processes. This is good but is why the device cannot be as fluid as those running EAS and is also why it consumes slightly more battery. This, finally, brings us to Energy Aware Scheduling (EAS), which I firmly believe is the future in ROM and kernel development as more OEMs adopt it.</p><h3 id="Energy-Aware-Scheduling"><a href="#Energy-Aware-Scheduling" class="headerlink" title="Energy Aware Scheduling"></a>Energy Aware Scheduling</h3><p>Energy Aware Scheduling (EAS) is the next big thing that users on our forums are talking about. If you use a OnePlus 3 (or a Google Pixel, obviously) you’ve definitely heard about it in the forums. It launched into the mainstream with the Qualcomm Snapdragon 845, so if you have one of these devices you already have an EAS-enabled smartphone. EAS in the form of kernels such as RenderZenith and ROMs such as VertexOS and PureFusion were taking the OnePlus 3 forums by storm in its prime. Of course, the Google Pixel also comes with EAS. With the promises of improved battery life and better performance, what’s the catch?</p><p>Energy Aware Scheduling is not as simple as it is not universal to every device like CFS or HMP. EAS requires an understanding of the processor it is running on, based off of an energy model. These energy models are made by teams of engineers constantly testing and working to give an optimal performance. As the Snapdragon 820 and 821 are basically the same, custom kernels on the OnePlus 3 uses the Google Pixel energy model. Devices with the Snapdragon 845 can utilise EAS, and the OnePlus 6 does to some degree. It’s not as tuned as a Google Pixel device would be, but it gets the job done. Here’s an example of how, despite the OnePlus 6 having a better processor with EAS, the Pixel 2 XL still beats it in smoothness. Both of these images were taken from our speed-oriented review of the OnePlus 6.<br><img src="ONEPLUS-A6003_scrolling_PlayStore_round2-1-1024x683.png" alt="avater"><br><img src="Pixel-2-XL_scrolling_PlayStore_round2-1-1024x683.png" alt="avater"></p><p>If you have trouble understanding the graphs, you can take a look at the image below for guidance. Anything exceeding the green line indicates dropped frames and, in the worst cases, noticeable stuttering.</p><p>The OnePlus 6 implementation of EAS is interesting, as it doesn’t appear to be a fully-fledged implementation like you’d find on a Google Pixel with the same SoC. The scheduler tunables don’t make much sense either, so that probably explains why it’s not as performance efficient as you’d expect. It’s extremely conservative in power consumption, with the system prioritising the low power cores for the majority of the work.</p><p>Tunables are simply a set of parameters that are passed to the CPU governor, which changes how the governor reacts to certain situations in terms of frequency. The scheduler then decides where it places tasks on different processors. The OnePlus 6’s tunables are set to prioritise work on low-powered cores. It also doesn’t help that the Google Pixel 2 has a huge amount of input boost, keeping all 8 cores online all the time. Google also uses an interrupt balancer which helps to remove frame drops and improve performance.</p><p>So how does EAS work? Why is it so efficient only in certain conditions?</p><p>Energy Aware Scheduling introduces the need to use an energy model, and as mentioned above requires a lot of testing and work to make it perfect. EAS attempts to unify three different core parts of the kernel which all act independently, and the energy model helps to unify them.</p><ul><li>Linux scheduler (CFS, mentioned above)</li><li>Linux cpuidle</li><li>Linux cpufreq</li></ul><p>Unifying all 3 parts under the scheduler and calculating them together gives a potential for energy saving, as calculating them together allows them to be as efficient as possible. CPUIdle tries to decide when the CPU should go into an idle mode, while CPUFreq tries to decide when to ramp up or down the CPU. Both of these modules have the primary goal of saving energy. Not only that, it then categorizes processes into four cgroups, being top-app, system-background, foreground, and background. Tasks due to be processed are placed into one of these categories, and then the category is given CPU power and the work is delegated over different CPU cores. top-app is the highest priority of completion, followed by foreground, background, and then system-background. Background technically has the same priority as system-background, but system-background usually also has access to more little cores. In effect, Energy Aware Scheduling is taking core parts of the Linux kernel and unifying it all into one process.</p><p>When waking the device, EAS will choose the core in the shallowest idle state, minimising the energy needed to wake the device. This helps to reduce the required power in using the device, as it will not wake up the large cluster if it doesn’t need to. Load tracking is also an extremely crucial part of EAS, and there are two options. “Per-Entity Load Tracking” (PELT) is usually used for load tracking, the information is then used to decide frequencies and how to delegate tasks across the CPU. “Window-Assisted Load Tracking” (WALT) can also be used and is what’s used on the Google Pixel. Many EAS ROMs on our forums, such as VertexOS, opt to use WALT. Many ROMs will release two versions of the kernel with WALT or PELT, so it’s up to the user to decide. WALT is more bursty, with high peaks in CPU frequency while PELT tries to remain more consistent. The load tracker doesn’t actually affect the CPU frequency, it just tells the system what the CPU usage is at. A higher CPU usage requires a higher frequency and so a consistent trait of PELT is that it causes the CPU frequency to ramp up or down slowly. PELT does tend to stray towards higher CPU load reporting, so it may provide higher performance at a higher battery cost. Nobody can really say at this point in time which load tracking system is better, however, as both load tracking methods are getting continually patched and refined.</p><p>Either way, it’s obvious that, regardless of the load tracking method used, there is an increase in efficiency. Rather than just processing tasks on any processor, the task is analyzed and the amount of energy required to run it is estimated. This clever task placement means that tasks get completed in a much more efficient manner while also making the system quicker as a whole. EAS is all about getting the smoothest UI possible with minimal power usage. This is where other external components such as schedtune come into play.</p><p>Schedtune is defined in each cgroup by two tunables which ensure finer control over the tasks to be completed. It doesn’t just control the spread out of tasks over multiple CPUs, but also if the perceived load should be inflated in order to ensure time-sensitive tasks are completed quicker. This way, foreground applications and services that the user is availing of won’t slow down and cause unnecessary performance issues.</p><p>While Energy Aware Scheduling is the next big thing, it can also be argued it’s already here and has been for a while. With more and more devices hitting the mainstream with Energy Aware Scheduling, a new age of mobile processing efficiency is here.</p><h4 id="The-Pros-and-Cons-of-Round-Robin-CFS-HMP-and-EAS"><a href="#The-Pros-and-Cons-of-Round-Robin-CFS-HMP-and-EAS" class="headerlink" title="The Pros and Cons of Round-Robin, CFS, HMP and EAS"></a>The Pros and Cons of Round-Robin, CFS, HMP and EAS</h4><p>While my graphics skills are sub-par, I have thrown together an image which should summarize what the pros and cons of each of these schedulers are.<br><img src="schedulers-1024x683.png" alt="avater"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Make</title>
      <link href="/Make/"/>
      <url>/Make/</url>
      
        <content type="html"><![CDATA[<h3 id="工程管理器make"><a href="#工程管理器make" class="headerlink" title="工程管理器make"></a>工程管理器make</h3><p>当我们要编译成千上万个源程序文件的时候，光靠手工地使用GCC工具来达到目的也许会很没有效率。make是Linux系统的实用程序。它用于管理对于大型程序的自动编译任务，自动决定程序某一部分需要重新编译，并发出编译指令。</p><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>Makefile是make的配置文件，用来配置运行make 的时候的一些相关细节，比如指定编译选项，指定编译环境等等。一般而言，一个工程项目不管是简单还是复杂，每一个源代码子目录都会有一个Makefile 来管理，然后一般有个所谓的顶层Makefile 来统一管理所有的子目录Makefile。</p><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p>简单的 Makefile 文件由若干如下格式的规则(rule)组成: target:通常是程序生成(输出)的一个或多个文件名，例如：可执行文件或目标文件；它也可以是要执行任务的名称，例如用于清理生成文件的 clean 任务。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>make 中的变量本质是一种宏替换，用于简化和维护重复出现的字符串和字符串列表。既可以出现在目标，先决条件，也可以出现在“菜谱”的 shell 命令中；可以是命令本身，也可以是命令的选项，或者输入输出文件；甚至也可以出现在另一个变量的引用中（计算变量）。</p><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>make 变量定义和 shell 变量的定义非常相似。不同的是 make 变量的名称可以是任何不包含 :, #, = 和空字符的字符序列，并且等号两边可以有空格（shell 定义变量的等号两个不允许出现空格）。</p><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>make 变量支持和 shell 变量一样，在变量标识符前加美元符 $ 来引用，因此，如果在”菜谱”中使用 shell 变量，需要使用双美元符 $$ 作为前缀加以区分；但更推荐的使用方式是使用美元符后跟一对圆括号的方式，例如使用上文创建的变量 objs ，可以这样 $(objs)。</p><h3 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h3><p>此类函数专门用于处理文本（字符串） </p><blockquote><p>$(subst FROM,TO,TEXT)</p></blockquote><ul><li>功能：将字符串TEXT 中的字符FROM 替换为TO。</li><li>返回：替换之后的新字符串</li><li>范例：A = $(subst pp,PP,apple tree)替换之后变量A 的值是”aPPle tree”</li></ul><blockquote><p>$(patsubst PATTERN,REPLACEMENT,TEXT)</p></blockquote><ul><li>功能：按照PATTERN 搜索TEXT 中所有以空格隔开的单词， 并将它们替换为REPLACEMENT。</li><li>注意：参数PATTERN 可以使用模式通配符%来代表一个单词中的若干字符，如果此时REPLACEMENT 中也出现%，那么REPLACEMENT 中的%跟PATTERN 中的%是一样的。</li><li>返回：替换之后的新字符串。范例：A = $(patsubst %.c,%.o,a.c b.c)替换之后变量A 的值是”a.o b.o”</li></ul><blockquote><p> $(strip STRING)</p></blockquote><ul><li>功能：去掉字符串中开头和结尾的多余的空白符（掐头去尾），并将其中连续的多个空白符合并为一个。</li><li>注意：所谓的空白符指的是空格、制表符。返回：去掉多余空白符之后的新字符串。</li><li>范例：A = $(strip apple tree )处理之后，变量A 的值是”apple tree”</li></ul><blockquote><p>$(findstring FIND, STRING)</p></blockquote><ul><li>功能：在给定的字符串STRING 中查找FIND 子串。</li><li>返回：找到则返回FIND，否额返回空。</li><li>范例：A = $(findstring pp, apple tree)B = $(findstring xx, apple tree)变量A 的值是”pp”，变量B 的值是空。</li></ul><blockquote><p>$(filter PATTERN,TEXT)</p></blockquote><ul><li>功能：过滤掉TEXT 中所有不符合给定模式PATTERN 的单词。其中PATTERN 可以是多个模式的组合。</li><li>返回：TEXT 中所有符合模式组合PATTERN 的单词组成的子串。</li><li>范例：A = a.c b.o c.s d.txt, B = $(filter %.c %.o,$(A))过滤后变量B 的值是”a.c b.o”。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>When Day is Done</title>
      <link href="/When-Day-is-Done/"/>
      <url>/When-Day-is-Done/</url>
      
        <content type="html"><![CDATA[<h3 id="If-the-day-is-done"><a href="#If-the-day-is-done" class="headerlink" title="If the day is done,"></a><em>If the day is done,</em></h3><h3 id="if-birds-sing-no-more"><a href="#if-birds-sing-no-more" class="headerlink" title="if birds sing no more."></a><em>if birds sing no more.</em></h3><h3 id="If-the-wind-has-fiagged-tired"><a href="#If-the-wind-has-fiagged-tired" class="headerlink" title="If the wind has fiagged tired,"></a><em>If the wind has fiagged tired,</em></h3><h3 id="Then-draw-the-veil-of-darkness-thick-upon-me"><a href="#Then-draw-the-veil-of-darkness-thick-upon-me" class="headerlink" title="Then draw the veil of darkness thick upon me,"></a><em>Then draw the veil of darkness thick upon me,</em></h3><h3 id="Even-as-thou-hast-wrapt-the-earth-with-The-coverlet-of-sleep-and-tenderly-closed"><a href="#Even-as-thou-hast-wrapt-the-earth-with-The-coverlet-of-sleep-and-tenderly-closed" class="headerlink" title="Even as thou hast wrapt the earth with The coverlet of sleep and tenderly closed,"></a><em>Even as thou hast wrapt the earth with The coverlet of sleep and tenderly closed,</em></h3><h3 id="The-petals-of-the-drooping-lotus-at-dusk"><a href="#The-petals-of-the-drooping-lotus-at-dusk" class="headerlink" title="The petals of the drooping lotus at dusk."></a><em>The petals of the drooping lotus at dusk.</em></h3><h3 id="From-the-traverer"><a href="#From-the-traverer" class="headerlink" title="From the traverer,"></a><em>From the traverer,</em></h3><h3 id="Whose-sack-of-provisions-is-empty-before-the-voyage-is-ended"><a href="#Whose-sack-of-provisions-is-empty-before-the-voyage-is-ended" class="headerlink" title="Whose sack of provisions is empty before the voyage is ended,"></a><em>Whose sack of provisions is empty before the voyage is ended,</em></h3><h3 id="Whose-garment-is-torn-and-dust-laden"><a href="#Whose-garment-is-torn-and-dust-laden" class="headerlink" title="Whose garment is torn and dust-laden,"></a><em>Whose garment is torn and dust-laden,</em></h3><h3 id="Whose-strength-is-exhausted-remove-shame-and-poverty"><a href="#Whose-strength-is-exhausted-remove-shame-and-poverty" class="headerlink" title="Whose strength is exhausted,remove shame and poverty,"></a><em>Whose strength is exhausted,remove shame and poverty,</em></h3><h3 id="And-renew-his-life-like-a-flower-under"><a href="#And-renew-his-life-like-a-flower-under" class="headerlink" title="And renew his life like a flower under"></a><em>And renew his life like a flower under</em></h3><h3 id="The-cover-of-thy-kindly-night"><a href="#The-cover-of-thy-kindly-night" class="headerlink" title="The cover of thy kindly night."></a><em>The cover of thy kindly night.</em></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>First blog</title>
      <link href="/First-blog/"/>
      <url>/First-blog/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.pexels.com/photos/699122/pexels-photo-699122.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=650&w=940" alt="avatar"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
